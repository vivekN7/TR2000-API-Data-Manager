-- ===============================================================================
-- Master DDL Script for TR2000 ETL System
-- ===============================================================================
-- This file contains ALL database schema definitions for the TR2000 ETL system.
-- No other DDL scripts should exist outside this file.
-- 
-- Schema Structure:
-- 1. RAW_JSON - Storage for API responses with deduplication
-- 2. STG_* - Staging tables with VARCHAR2 columns for parsing
-- 3. CORE.* - Final normalized tables with proper data types
-- 4. Control Tables - ETL orchestration and monitoring
-- ===============================================================================

-- ===============================================================================
-- SECTION 1: RAW_JSON Storage
-- ===============================================================================
-- Stores raw API responses with SHA256 hash for deduplication
CREATE TABLE RAW_JSON (
    raw_json_id         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    endpoint_key        VARCHAR2(100) NOT NULL,  -- e.g., 'plants', 'issues'
    plant_id            VARCHAR2(50),            -- Plant context if applicable
    issue_revision      VARCHAR2(50),            -- Issue revision if applicable
    api_url             VARCHAR2(500) NOT NULL,  -- Full API URL called
    response_json       CLOB NOT NULL,           -- Raw JSON response
    response_hash       VARCHAR2(64) NOT NULL,   -- SHA256 hash for deduplication
    api_call_timestamp  TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    created_date        DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT uk_raw_json_hash UNIQUE (response_hash)
);

CREATE INDEX idx_raw_json_endpoint ON RAW_JSON(endpoint_key);
CREATE INDEX idx_raw_json_plant ON RAW_JSON(plant_id);
CREATE INDEX idx_raw_json_issue ON RAW_JSON(issue_revision);
CREATE INDEX idx_raw_json_timestamp ON RAW_JSON(api_call_timestamp);

-- ===============================================================================
-- SECTION 2: Staging Tables
-- ===============================================================================

-- STG_PLANTS - Staging for Plants endpoint (all VARCHAR2 for initial parsing)
CREATE TABLE STG_PLANTS (
    stg_plants_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    raw_json_id         NUMBER NOT NULL,
    operator_id         VARCHAR2(50),
    operator_name       VARCHAR2(255),
    plant_id            VARCHAR2(50) NOT NULL,
    short_description   VARCHAR2(255),
    project             VARCHAR2(255),
    long_description    VARCHAR2(4000),
    common_lib_plant_code VARCHAR2(50),
    initial_revision    VARCHAR2(50),
    area_id             VARCHAR2(50),
    area                VARCHAR2(255),
    enable_embedded_note VARCHAR2(50),
    category_id         VARCHAR2(50),
    category            VARCHAR2(255),
    document_space_link VARCHAR2(500),
    enable_copy_pcs_from_plant VARCHAR2(50),
    over_length         VARCHAR2(50),
    pcs_qa              VARCHAR2(50),
    eds_mj              VARCHAR2(50),
    celsius_bar         VARCHAR2(50),
    web_info_text       VARCHAR2(4000),
    bolt_tension_text   VARCHAR2(4000),
    visible             VARCHAR2(50),
    windows_remark_text VARCHAR2(4000),
    user_protected      VARCHAR2(50),
    processed_timestamp TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT fk_stg_plants_raw FOREIGN KEY (raw_json_id) REFERENCES RAW_JSON(raw_json_id)
);

CREATE INDEX idx_stg_plants_raw ON STG_PLANTS(raw_json_id);
CREATE INDEX idx_stg_plants_plant ON STG_PLANTS(plant_id);

-- STG_ISSUES - Staging for Issues endpoint (all VARCHAR2 for initial parsing)
CREATE TABLE STG_ISSUES (
    stg_issues_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    raw_json_id         NUMBER NOT NULL,
    plant_id            VARCHAR2(50) NOT NULL,
    issue_revision      VARCHAR2(50) NOT NULL,
    status              VARCHAR2(50),
    rev_date            VARCHAR2(50),
    protect_status      VARCHAR2(50),
    general_revision    VARCHAR2(50),
    general_rev_date    VARCHAR2(50),
    pcs_revision        VARCHAR2(50),
    pcs_rev_date        VARCHAR2(50),
    eds_revision        VARCHAR2(50),
    eds_rev_date        VARCHAR2(50),
    vds_revision        VARCHAR2(50),
    vds_rev_date        VARCHAR2(50),
    vsk_revision        VARCHAR2(50),
    vsk_rev_date        VARCHAR2(50),
    mds_revision        VARCHAR2(50),
    mds_rev_date        VARCHAR2(50),
    esk_revision        VARCHAR2(50),
    esk_rev_date        VARCHAR2(50),
    sc_revision         VARCHAR2(50),
    sc_rev_date         VARCHAR2(50),
    vsm_revision        VARCHAR2(50),
    vsm_rev_date        VARCHAR2(50),
    user_name           VARCHAR2(255),
    user_entry_time     VARCHAR2(50),
    user_protected      VARCHAR2(50),
    processed_timestamp TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    CONSTRAINT fk_stg_issues_raw FOREIGN KEY (raw_json_id) REFERENCES RAW_JSON(raw_json_id)
);

CREATE INDEX idx_stg_issues_raw ON STG_ISSUES(raw_json_id);
CREATE INDEX idx_stg_issues_plant ON STG_ISSUES(plant_id);
CREATE INDEX idx_stg_issues_revision ON STG_ISSUES(issue_revision);

-- ===============================================================================
-- SECTION 3: Core Tables
-- ===============================================================================

-- Create CORE schema if not exists
-- Note: Schema creation requires DBA privileges
-- CREATE USER core IDENTIFIED BY core_password;
-- GRANT CREATE SESSION, CREATE TABLE, CREATE SEQUENCE, CREATE PROCEDURE TO core;

-- CORE.PLANTS - Final normalized Plants table with proper data types
CREATE TABLE CORE.PLANTS (
    plant_id            VARCHAR2(50) PRIMARY KEY,
    operator_id         NUMBER,
    operator_name       VARCHAR2(255),
    short_description   VARCHAR2(255),
    project             VARCHAR2(255),
    long_description    VARCHAR2(4000),
    common_lib_plant_code VARCHAR2(50),
    initial_revision    VARCHAR2(50),
    area_id             NUMBER,
    area                VARCHAR2(255),
    enable_embedded_note CHAR(1) DEFAULT 'N' CHECK (enable_embedded_note IN ('Y', 'N')),
    category_id         VARCHAR2(50),
    category            VARCHAR2(255),
    document_space_link VARCHAR2(500),
    enable_copy_pcs_from_plant CHAR(1) DEFAULT 'N' CHECK (enable_copy_pcs_from_plant IN ('Y', 'N')),
    over_length         CHAR(1) DEFAULT 'N' CHECK (over_length IN ('Y', 'N')),
    pcs_qa              CHAR(1) DEFAULT 'N' CHECK (pcs_qa IN ('Y', 'N')),
    eds_mj              CHAR(1) DEFAULT 'N' CHECK (eds_mj IN ('Y', 'N')),
    celsius_bar         CHAR(1) DEFAULT 'N' CHECK (celsius_bar IN ('Y', 'N')),
    web_info_text       VARCHAR2(4000),
    bolt_tension_text   VARCHAR2(4000),
    visible             CHAR(1) DEFAULT 'Y' CHECK (visible IN ('Y', 'N')),
    windows_remark_text VARCHAR2(4000),
    user_protected      CHAR(1) DEFAULT 'N' CHECK (user_protected IN ('Y', 'N')),
    is_valid            CHAR(1) DEFAULT 'Y' NOT NULL CHECK (is_valid IN ('Y', 'N')),
    created_date        DATE DEFAULT SYSDATE NOT NULL,
    last_modified_date  DATE DEFAULT SYSDATE NOT NULL,
    last_api_sync       TIMESTAMP
);

CREATE INDEX idx_core_plants_operator ON CORE.PLANTS(operator_id);
CREATE INDEX idx_core_plants_valid ON CORE.PLANTS(is_valid);
CREATE INDEX idx_core_plants_sync ON CORE.PLANTS(last_api_sync);

-- CORE.ISSUES - Final normalized Issues table with proper data types
CREATE TABLE CORE.ISSUES (
    issue_id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plant_id            VARCHAR2(50) NOT NULL,
    issue_revision      VARCHAR2(50) NOT NULL,
    status              VARCHAR2(50),
    rev_date            DATE,
    protect_status      VARCHAR2(50),
    general_revision    VARCHAR2(50),
    general_rev_date    DATE,
    pcs_revision        VARCHAR2(50),
    pcs_rev_date        DATE,
    eds_revision        VARCHAR2(50),
    eds_rev_date        DATE,
    vds_revision        VARCHAR2(50),
    vds_rev_date        DATE,
    vsk_revision        VARCHAR2(50),
    vsk_rev_date        DATE,
    mds_revision        VARCHAR2(50),
    mds_rev_date        DATE,
    esk_revision        VARCHAR2(50),
    esk_rev_date        DATE,
    sc_revision         VARCHAR2(50),
    sc_rev_date         DATE,
    vsm_revision        VARCHAR2(50),
    vsm_rev_date        DATE,
    user_name           VARCHAR2(255),
    user_entry_time     TIMESTAMP,
    user_protected      CHAR(1) DEFAULT 'N' CHECK (user_protected IN ('Y', 'N')),
    is_valid            CHAR(1) DEFAULT 'Y' NOT NULL CHECK (is_valid IN ('Y', 'N')),
    created_date        DATE DEFAULT SYSDATE NOT NULL,
    last_modified_date  DATE DEFAULT SYSDATE NOT NULL,
    last_api_sync       TIMESTAMP,
    CONSTRAINT uk_core_issues UNIQUE (plant_id, issue_revision),
    CONSTRAINT fk_core_issues_plant FOREIGN KEY (plant_id) REFERENCES CORE.PLANTS(plant_id)
);

CREATE INDEX idx_core_issues_plant ON CORE.ISSUES(plant_id);
CREATE INDEX idx_core_issues_revision ON CORE.ISSUES(issue_revision);
CREATE INDEX idx_core_issues_valid ON CORE.ISSUES(is_valid);
CREATE INDEX idx_core_issues_sync ON CORE.ISSUES(last_api_sync);

-- ===============================================================================
-- SECTION 4: Selection Management
-- ===============================================================================

-- SELECTION_LOADER - Stores user-selected plants and issues for ETL processing
CREATE TABLE SELECTION_LOADER (
    selection_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plant_id            VARCHAR2(50) NOT NULL,
    issue_revision      VARCHAR2(50),  -- NULL means all issues for the plant
    is_active           CHAR(1) DEFAULT 'Y' NOT NULL CHECK (is_active IN ('Y', 'N')),
    selected_by         VARCHAR2(50),
    selection_date      DATE DEFAULT SYSDATE NOT NULL,
    last_etl_run        TIMESTAMP,
    etl_status          VARCHAR2(50),
    CONSTRAINT uk_selection_loader UNIQUE (plant_id, issue_revision)
);

CREATE INDEX idx_selection_plant ON SELECTION_LOADER(plant_id);
CREATE INDEX idx_selection_active ON SELECTION_LOADER(is_active);

-- ===============================================================================
-- SECTION 5: ETL Control Tables
-- ===============================================================================

-- CONTROL_ENDPOINTS - Defines available endpoints for ETL processing
CREATE TABLE CONTROL_ENDPOINTS (
    endpoint_id         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    endpoint_key        VARCHAR2(100) NOT NULL UNIQUE,
    endpoint_url_pattern VARCHAR2(500) NOT NULL,
    endpoint_description VARCHAR2(500),
    processing_order    NUMBER NOT NULL,
    is_active           CHAR(1) DEFAULT 'Y' NOT NULL CHECK (is_active IN ('Y', 'N')),
    requires_plant      CHAR(1) DEFAULT 'N' NOT NULL CHECK (requires_plant IN ('Y', 'N')),
    requires_issue      CHAR(1) DEFAULT 'N' NOT NULL CHECK (requires_issue IN ('Y', 'N')),
    parse_procedure     VARCHAR2(100),  -- Name of parsing procedure
    upsert_procedure    VARCHAR2(100),  -- Name of upsert procedure
    created_date        DATE DEFAULT SYSDATE NOT NULL
);

CREATE INDEX idx_control_endpoints_active ON CONTROL_ENDPOINTS(is_active);
CREATE INDEX idx_control_endpoints_order ON CONTROL_ENDPOINTS(processing_order);

-- CONTROL_SETTINGS - Global ETL settings
CREATE TABLE CONTROL_SETTINGS (
    setting_key         VARCHAR2(100) PRIMARY KEY,
    setting_value       VARCHAR2(500),
    setting_description VARCHAR2(500),
    last_modified       DATE DEFAULT SYSDATE NOT NULL
);

-- CONTROL_ENDPOINT_STATE - Tracks last successful sync per endpoint
CREATE TABLE CONTROL_ENDPOINT_STATE (
    state_id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    endpoint_key        VARCHAR2(100) NOT NULL,
    plant_id            VARCHAR2(50),
    issue_revision      VARCHAR2(50),
    last_sync_timestamp TIMESTAMP,
    last_response_hash  VARCHAR2(64),
    sync_status         VARCHAR2(50),
    error_message       VARCHAR2(4000),
    created_date        DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT uk_endpoint_state UNIQUE (endpoint_key, plant_id, issue_revision)
);

CREATE INDEX idx_endpoint_state_key ON CONTROL_ENDPOINT_STATE(endpoint_key);
CREATE INDEX idx_endpoint_state_plant ON CONTROL_ENDPOINT_STATE(plant_id);

-- ===============================================================================
-- SECTION 6: ETL Monitoring and Logging
-- ===============================================================================

-- ETL_RUN_LOG - Tracks ETL execution runs
CREATE TABLE ETL_RUN_LOG (
    run_id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_type            VARCHAR2(50) NOT NULL,  -- 'MANUAL', 'SCHEDULED', 'API_TRIGGERED'
    endpoint_key        VARCHAR2(100),
    plant_id            VARCHAR2(50),
    issue_revision      VARCHAR2(50),
    start_time          TIMESTAMP NOT NULL,
    end_time            TIMESTAMP,
    status              VARCHAR2(50) NOT NULL,  -- 'RUNNING', 'SUCCESS', 'FAILED', 'PARTIAL'
    records_processed   NUMBER DEFAULT 0,
    records_inserted    NUMBER DEFAULT 0,
    records_updated     NUMBER DEFAULT 0,
    records_invalidated NUMBER DEFAULT 0,
    error_count         NUMBER DEFAULT 0,
    duration_seconds    NUMBER,
    initiated_by        VARCHAR2(50),
    notes               VARCHAR2(4000)
);

CREATE INDEX idx_etl_run_log_status ON ETL_RUN_LOG(status);
CREATE INDEX idx_etl_run_log_endpoint ON ETL_RUN_LOG(endpoint_key);
CREATE INDEX idx_etl_run_log_plant ON ETL_RUN_LOG(plant_id);
CREATE INDEX idx_etl_run_log_start ON ETL_RUN_LOG(start_time);

-- ETL_ERROR_LOG - Detailed error tracking for ETL operations
CREATE TABLE ETL_ERROR_LOG (
    error_id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_id              NUMBER,
    endpoint_key        VARCHAR2(100),
    plant_id            VARCHAR2(50),
    issue_revision      VARCHAR2(50),
    error_timestamp     TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    error_type          VARCHAR2(50),  -- 'API_ERROR', 'PARSE_ERROR', 'DB_ERROR', 'VALIDATION_ERROR'
    error_code          VARCHAR2(50),
    error_message       VARCHAR2(4000),
    error_stack         CLOB,
    raw_data            CLOB,  -- Store problematic data for debugging
    resolution_status   VARCHAR2(50) DEFAULT 'OPEN',  -- 'OPEN', 'ACKNOWLEDGED', 'RESOLVED'
    resolved_by         VARCHAR2(50),
    resolution_notes    VARCHAR2(4000),
    CONSTRAINT fk_etl_error_run FOREIGN KEY (run_id) REFERENCES ETL_RUN_LOG(run_id)
);

CREATE INDEX idx_etl_error_log_run ON ETL_ERROR_LOG(run_id);
CREATE INDEX idx_etl_error_log_endpoint ON ETL_ERROR_LOG(endpoint_key);
CREATE INDEX idx_etl_error_log_plant ON ETL_ERROR_LOG(plant_id);
CREATE INDEX idx_etl_error_log_type ON ETL_ERROR_LOG(error_type);
CREATE INDEX idx_etl_error_log_timestamp ON ETL_ERROR_LOG(error_timestamp);
CREATE INDEX idx_etl_error_log_status ON ETL_ERROR_LOG(resolution_status);

-- ===============================================================================
-- SECTION 7: Initial Data Population
-- ===============================================================================

-- Populate CONTROL_ENDPOINTS with Plants and Issues configurations
INSERT INTO CONTROL_ENDPOINTS (
    endpoint_key, 
    endpoint_url_pattern, 
    endpoint_description, 
    processing_order, 
    is_active,
    requires_plant,
    requires_issue,
    parse_procedure,
    upsert_procedure
) VALUES 
    ('plants', 
     'plants', 
     'Get all plants with metadata', 
     1, 
     'Y',
     'N',
     'N',
     'pkg_parse_plants.parse_plants_json',
     'pkg_upsert_plants.upsert_plants'),
    
    ('issues', 
     'plants/{plantid}/issues', 
     'Get issue revisions for a specific plant', 
     2, 
     'Y',
     'Y',
     'N',
     'pkg_parse_issues.parse_issues_json',
     'pkg_upsert_issues.upsert_issues');

-- Populate initial CONTROL_SETTINGS
INSERT INTO CONTROL_SETTINGS (setting_key, setting_value, setting_description) VALUES
    ('API_BASE_URL', 'https://equinor.pipespec-api.presight.com/', 'Base URL for TR2000 API'),
    ('API_TIMEOUT_SECONDS', '60', 'API call timeout in seconds'),
    ('MAX_PLANTS_PER_RUN', '10', 'Maximum number of plants to process in a single ETL run'),
    ('RAW_JSON_RETENTION_DAYS', '30', 'Number of days to retain raw JSON responses'),
    ('ETL_LOG_RETENTION_DAYS', '90', 'Number of days to retain ETL logs'),
    ('ENABLE_PARALLEL_PROCESSING', 'N', 'Enable parallel processing of endpoints'),
    ('BATCH_SIZE', '1000', 'Batch size for bulk operations');

COMMIT;

-- ===============================================================================
-- END OF MASTER DDL
-- ===============================================================================