# RAW_JSON Architecture - GPT-5 Recommended Design

## Overview

This document outlines the industry-standard RAW_JSON architecture recommended by GPT-5 analysis to replace the current broken implementation where RAW_JSON is bypassed entirely.

## Current Problem (Identified Session 27)

### **Architecture Violation:**
- **Current (Wrong)**: API → STG_TABLES → ISSUES (bypassing RAW_JSON entirely)
- **Industry Standard**: API → RAW_JSON → STG_TABLES → ISSUES

### **Root Cause:**
Parameter mismatch between C# code and Oracle procedure:
- **C# sends**: 7 parameters (endpoint, keyString, etlRunId, httpStatus, durationMs, headers, payload)
- **Oracle expects**: 4 parameters (ETL_RUN_ID, ENDPOINT_NAME, PLANT_ID, JSON_DATA)

### **Impact:**
- No audit trail of actual API responses
- No ability to replay or debug data issues  
- Missing the core benefit of the three-layer architecture
- Violation of industry ETL standards

## GPT-5 Recommended Solution

### **Enhanced RAW_JSON Table Structure:**
```sql
DROP TABLE RAW_JSON;

CREATE TABLE RAW_JSON (
  JSON_ID            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ETL_RUN_ID         NUMBER,
  ENDPOINT_NAME      VARCHAR2(100) NOT NULL,
  REQUEST_URL        VARCHAR2(1000),
  REQUEST_PARAMS     CLOB,
  RESPONSE_STATUS    NUMBER,
  PLANT_ID           VARCHAR2(50),
  CREATED_DATE       TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  JSON_DATA          CLOB CHECK (JSON_DATA IS JSON),
  RESP_HASH_SHA256   RAW(32) NOT NULL,
  PROCESSED_FLAG     CHAR(1) DEFAULT 'N' CHECK (PROCESSED_FLAG IN ('Y','N'))
);

-- Performance and functionality indexes
CREATE INDEX IX_RAWJSON_PICK
  ON RAW_JSON (ENDPOINT_NAME, PROCESSED_FLAG, CREATED_DATE);

CREATE INDEX IX_RAWJSON_HASH
  ON RAW_JSON (RESP_HASH_SHA256);

-- Optional JSON search index for ad-hoc queries
CREATE SEARCH INDEX SIDX_RAWJSON_BODY
  ON RAW_JSON(JSON_DATA)
  FOR JSON;
```

### **Updated SP_INSERT_RAW_JSON Procedure:**
```sql
CREATE OR REPLACE PROCEDURE SP_INSERT_RAW_JSON(
    p_etl_run_id     NUMBER,
    p_endpoint       VARCHAR2,
    p_request_url    VARCHAR2,
    p_request_params CLOB,
    p_response_status NUMBER,
    p_plant_id       VARCHAR2,
    p_json_data      CLOB,
    p_duration_ms    NUMBER DEFAULT NULL,
    p_headers        CLOB DEFAULT NULL
) AS
    v_hash RAW(32);
BEGIN
    -- Compute hash for deduplication
    v_hash := STANDARD_HASH(p_json_data, 'SHA256');
    
    -- Insert with comprehensive metadata
    INSERT INTO RAW_JSON (
        ETL_RUN_ID, ENDPOINT_NAME, REQUEST_URL, REQUEST_PARAMS,
        RESPONSE_STATUS, PLANT_ID, JSON_DATA, RESP_HASH_SHA256
    ) VALUES (
        p_etl_run_id, p_endpoint, p_request_url, p_request_params,
        p_response_status, p_plant_id, p_json_data, v_hash
    );
    
EXCEPTION
    WHEN OTHERS THEN
        -- Don't let RAW_JSON failures break ETL
        NULL;
END SP_INSERT_RAW_JSON;
/
```

## Industry Standard Data Flow

### **Phase 1: API Ingestion (C# Responsibility)**
```csharp
// 1. Fetch from API
var apiResponse = await _apiService.FetchDataAsync(endpoint);

// 2. Insert to RAW_JSON with comprehensive metadata
await connection.ExecuteAsync(@"
    BEGIN
        SP_INSERT_RAW_JSON(
            p_etl_run_id     => :etlRunId,
            p_endpoint       => :endpoint,
            p_request_url    => :requestUrl,
            p_request_params => :requestParams,
            p_response_status => :httpStatus,
            p_plant_id       => :plantId,
            p_json_data      => :jsonData,
            p_duration_ms    => :durationMs,
            p_headers        => :headers
        );
    END;",
    new { 
        etlRunId, endpoint, requestUrl, requestParams, 
        httpStatus, plantId, jsonData, durationMs, headers 
    });
```

### **Phase 2: JSON Parsing (Oracle Responsibility)**
```sql
-- Parse RAW_JSON to staging using Oracle JSON_TABLE
CREATE OR REPLACE PROCEDURE SP_PARSE_RAW_JSON_TO_STAGING(
    p_endpoint VARCHAR2
) AS
BEGIN
    -- Example for ISSUES endpoint
    IF p_endpoint LIKE '%/issues' THEN
        INSERT INTO STG_ISSUES (
            RAW_JSON_ID, ETL_RUN_ID, PLANT_ID, ISSUE_REVISION, 
            STATUS, REV_DATE, PROTECT_STATUS, USER_NAME, USER_ENTRY_TIME, ...
        )
        SELECT 
            r.JSON_ID,
            r.ETL_RUN_ID,
            jt.*
        FROM RAW_JSON r
        CROSS APPLY JSON_TABLE(
            r.JSON_DATA,
            '$[*]'
            COLUMNS (
                plant_id        VARCHAR2(50)  PATH '$.PlantID',
                issue_revision  VARCHAR2(50)  PATH '$.IssueRevision',
                status          VARCHAR2(50)  PATH '$.Status',
                rev_date        VARCHAR2(100) PATH '$.RevDate',
                protect_status  VARCHAR2(50)  PATH '$.ProtectStatus',
                user_name       VARCHAR2(100) PATH '$.UserName',
                user_entry_time VARCHAR2(100) PATH '$.UserEntryTime',
                user_protected  CHAR(1)       PATH '$.UserProtected',
                -- Add all 25+ ISSUES fields here
                ...
            )
        ) jt
        WHERE r.ENDPOINT_NAME = p_endpoint
          AND r.PROCESSED_FLAG = 'N';
        
        -- Mark as processed
        UPDATE RAW_JSON 
           SET PROCESSED_FLAG = 'Y'
         WHERE ENDPOINT_NAME = p_endpoint
           AND PROCESSED_FLAG = 'N';
    END IF;
END SP_PARSE_RAW_JSON_TO_STAGING;
/
```

### **Phase 3: SCD2 Processing (Existing - No Changes)**
```sql
-- Existing PKG_*_ETL packages process STG → DIM tables
-- This layer remains unchanged - only source changes from API to RAW_JSON
```

## Enhanced Staging Tables

### **Add RAW_JSON Lineage to All Staging Tables:**
```sql
-- Example: STG_ISSUES enhancement
ALTER TABLE STG_ISSUES ADD (
    RAW_JSON_ID NUMBER REFERENCES RAW_JSON(JSON_ID)
);

-- Example: STG_PLANTS enhancement  
ALTER TABLE STG_PLANTS ADD (
    RAW_JSON_ID NUMBER REFERENCES RAW_JSON(JSON_ID)
);

-- Apply to all staging tables: STG_OPERATORS, STG_VDS_REFERENCES, etc.
```

## Deduplication Strategy

### **Hash-Based Deduplication:**
```sql
-- Prevent duplicate API responses
CREATE OR REPLACE FUNCTION IS_DUPLICATE_RESPONSE(
    p_hash RAW
) RETURN CHAR AS
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
      INTO v_count
      FROM RAW_JSON
     WHERE RESP_HASH_SHA256 = p_hash
       AND CREATED_DATE > SYSDATE - 1; -- Within last 24 hours
    
    RETURN CASE WHEN v_count > 0 THEN 'Y' ELSE 'N' END;
END;
/
```

## Replay Functionality

### **Replay Specific Time Periods:**
```sql
-- Replay all data from specific date range
CREATE OR REPLACE PROCEDURE SP_REPLAY_FROM_RAW_JSON(
    p_start_date DATE,
    p_end_date   DATE,
    p_endpoint   VARCHAR2 DEFAULT NULL
) AS
BEGIN
    -- Reset processed flags for replay
    UPDATE RAW_JSON
       SET PROCESSED_FLAG = 'N'
     WHERE CREATED_DATE BETWEEN p_start_date AND p_end_date
       AND (p_endpoint IS NULL OR ENDPOINT_NAME = p_endpoint);
    
    -- Re-parse to staging
    SP_PARSE_RAW_JSON_TO_STAGING(p_endpoint);
    
    -- Trigger SCD2 processing
    SP_PROCESS_ETL_BATCH('REPLAY', 0);
END SP_REPLAY_FROM_RAW_JSON;
/
```

## Benefits of New Architecture

### **Technical Benefits:**
1. **Complete Audit Trail** - Every API response preserved with metadata
2. **Replay Capability** - Re-process data without hitting API again
3. **Schema Drift Safety** - New API fields captured automatically
4. **Deduplication** - Hash-based duplicate prevention
5. **Lineage Tracking** - Every record traceable to source RAW_JSON
6. **Industry Compliance** - Follows standard ETL patterns

### **Operational Benefits:**
1. **Better Debugging** - Complete API response history available
2. **Data Recovery** - Replay specific time periods or endpoints
3. **Reduced API Dependency** - Less reliance on external API for debugging
4. **Compliance Ready** - Full audit trail for regulatory requirements

### **Performance Benefits:**
1. **Smart Workflow Maintained** - 98.5% API reduction preserved
2. **Efficient Parsing** - Oracle JSON_TABLE optimized performance
3. **Controlled Growth** - 30-day retention with compression
4. **Indexed Access** - Fast queries on processed flags and dates

## Migration Strategy (Session 28)

### **Phase 1: Update Oracle DDL**
1. Update RAW_JSON table structure
2. Update SP_INSERT_RAW_JSON procedure
3. Create JSON_TABLE parsing procedures
4. Add RAW_JSON_ID columns to staging tables

### **Phase 2: Update C# Code**
1. Fix InsertRawJson method parameter mismatch
2. Update ETL flow to parse from RAW_JSON
3. Add processed flag management

### **Phase 3: Testing**
1. Test new architecture end-to-end
2. Validate audit trail functionality
3. Test replay capability
4. Ensure Smart Workflow performance maintained

## Expected Timeline

- **Session 28**: Phase 1 & 2 implementation
- **Session 29**: Phase 3 testing and validation
- **Session 30**: Production deployment and monitoring

---
**Document Status**: Ready for Session 28 Implementation
**Priority**: Critical - Fundamental architecture fix required
**Dependencies**: None - Core ETL working, only need to fix RAW_JSON layer