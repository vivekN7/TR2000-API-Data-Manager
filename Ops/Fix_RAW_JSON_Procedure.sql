-- Fixed SP_INSERT_RAW_JSON procedure for Oracle compatibility
-- This version handles Oracle-specific syntax issues

-- Drop the procedure if it exists (to recreate clean)
BEGIN
    EXECUTE IMMEDIATE 'DROP PROCEDURE SP_INSERT_RAW_JSON';
EXCEPTION
    WHEN OTHERS THEN
        NULL; -- Ignore if doesn't exist
END;
/

-- Create the RAW_JSON table if it doesn't exist
BEGIN
    EXECUTE IMMEDIATE '
    CREATE TABLE RAW_JSON (
        JSON_ID            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        ETL_RUN_ID         NUMBER,
        ENDPOINT_NAME      VARCHAR2(100) NOT NULL,
        REQUEST_URL        VARCHAR2(1000),
        REQUEST_PARAMS     CLOB,
        RESPONSE_STATUS    NUMBER,
        PLANT_ID           VARCHAR2(50),
        CREATED_DATE       TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
        JSON_DATA          CLOB CHECK (JSON_DATA IS JSON),
        RESP_HASH_SHA256   RAW(32) NOT NULL,
        PROCESSED_FLAG     CHAR(1) DEFAULT ''N'' CHECK (PROCESSED_FLAG IN (''Y'',''N'')),
        DURATION_MS        NUMBER,
        HEADERS_JSON       CLOB
    ) LOB (JSON_DATA) STORE AS SECUREFILE (
        COMPRESS MEDIUM
        DEDUPLICATE
    )';
EXCEPTION
    WHEN OTHERS THEN
        NULL; -- Table might already exist
END;
/

-- Create indexes if they don't exist
BEGIN
    EXECUTE IMMEDIATE 'CREATE INDEX IX_RAWJSON_PICK ON RAW_JSON (ENDPOINT_NAME, PROCESSED_FLAG, CREATED_DATE)';
EXCEPTION
    WHEN OTHERS THEN NULL;
END;
/

BEGIN
    EXECUTE IMMEDIATE 'CREATE INDEX IX_RAWJSON_HASH ON RAW_JSON (RESP_HASH_SHA256)';
EXCEPTION
    WHEN OTHERS THEN NULL;
END;
/

-- Create the corrected SP_INSERT_RAW_JSON procedure
CREATE OR REPLACE PROCEDURE SP_INSERT_RAW_JSON(
    p_etl_run_id     NUMBER,
    p_endpoint       VARCHAR2,
    p_request_url    VARCHAR2 DEFAULT NULL,
    p_request_params CLOB DEFAULT NULL,
    p_response_status NUMBER DEFAULT 200,
    p_plant_id       VARCHAR2 DEFAULT NULL,
    p_json_data      CLOB,
    p_duration_ms    NUMBER DEFAULT NULL,
    p_headers        CLOB DEFAULT NULL
) AS
    v_hash RAW(32);
BEGIN
    -- Compute hash for deduplication
    v_hash := STANDARD_HASH(p_json_data, 'SHA256');
    
    -- Insert with comprehensive metadata
    INSERT INTO RAW_JSON (
        ETL_RUN_ID, ENDPOINT_NAME, REQUEST_URL, REQUEST_PARAMS,
        RESPONSE_STATUS, PLANT_ID, JSON_DATA, RESP_HASH_SHA256,
        DURATION_MS, HEADERS_JSON
    ) VALUES (
        p_etl_run_id, p_endpoint, p_request_url, p_request_params,
        p_response_status, p_plant_id, p_json_data, v_hash,
        p_duration_ms, p_headers
    );
    
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        -- Re-raise the exception for proper error handling
        RAISE;
END SP_INSERT_RAW_JSON;
/

-- Test the procedure
DECLARE
    v_test_json CLOB := '{"test": "data", "timestamp": "' || TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') || '"}';
BEGIN
    SP_INSERT_RAW_JSON(
        p_etl_run_id     => 999,
        p_endpoint       => 'test',
        p_request_url    => 'https://test.com/test',
        p_request_params => '{}',
        p_response_status => 200,
        p_plant_id       => 'TEST_PLANT',
        p_json_data      => v_test_json,
        p_duration_ms    => 150,
        p_headers        => '{"Content-Type": "application/json"}'
    );
    DBMS_OUTPUT.PUT_LINE('SP_INSERT_RAW_JSON created and tested successfully!');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        RAISE;
END;
/

-- Verify the test record was inserted
SELECT 
    JSON_ID, 
    ETL_RUN_ID, 
    ENDPOINT_NAME, 
    PLANT_ID, 
    CREATED_DATE,
    LENGTH(JSON_DATA) as JSON_SIZE
FROM RAW_JSON 
WHERE ENDPOINT_NAME = 'test'
ORDER BY CREATED_DATE DESC;

DBMS_OUTPUT.PUT_LINE('RAW_JSON procedure is ready for ETL operations!');